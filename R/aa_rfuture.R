# Generated by r6-generator-maven-plugin: this file is embedded into the R directory in R6-generator projects

#' R6 RFuture class
#'
#' @description
#' This implements functions to check on the status of a Java process running
#' in a thread and determine if it has finished, or cancel it if needs be.
#' This is low level as async classes go as the main goal is to put the java
#' process into a state in which interruptions in the R process can cancel
#' the Java thread.
#'
#' @keywords internal
#'
#' @details
#' no details
#' @export
RFuture = R6::R6Class("RFuture", public=list(
	
	# TODO make fields private
				
	#' @field .r6obj the r6obj creating this future.
	.r6obj = NULL,
	
	#' @field .api the java api.
	.api = NULL,
	
	#' @field .method the method name that is being called asynchronously
	.method = NULL,
	
	#' @field .jthread internal pointer to the rJava reference to the java threadrunner.
	.jthread = NULL,
	
	#' @field .converter converts the Java return value to an R object
	.converter = NULL,
	
	#' @field .returnSig the return signature of the expected object.
	.returnSig = NULL,
	
	#' @description
	#' Create a new JFuture. This is done automatically by the API.
	#' @param r6obj The r6obj creating this future, or the canonical java class name of a static java class
	#' @param api The java api
	#' @param method The java method name to be called async
	#' @param returnSig The JNI return signature
	#' @param converter The R6 api function that the return value should use
	#' @param ... parameters to pass to the java method
	#' @return A new RFuture holding the java thread executing the method.
	initialize = function(
		r6obj,
		method,
		returnSig,
		converter,
		...,
		api = r6obj$.api
	){
		params = rlang::list2(...)
		jparams = .jnew('java/util/ArrayList')
		lapply(params, function(p) {
			.jcall(jparams, returnSig = "Z", method="add", .jcast(p,"java/lang/Object"))		
		})
		self$.r6obj = r6obj;
		self$.api = api;
		self$.method = method;
		self$.returnSig = returnSig;
		self$.converter = converter;
		tmp = if (is.R6(r6obj)) r6obj$.jobj else .jnew("java/lang/String",r6obj)
		self$.jthread = .jnew(
			'uk/co/terminological/rjava/RFuture',
			.jcast(tmp, "java/lang/Object"),
			method,
			jparams
		)
	},
	
	#' @description 
	#' cancel execution of the async function
	cancel = function() {
		# interrupt the thread.
		rJava::.jcall(self$.jthread, returnSig='Z', method='cancel')
	},
	
	#' @description 
	#' has the function been cancelled
	isCancelled = function() {
		as.logical(rJava::.jcall(self$.jthread, returnSig='Z', method='isCancelled'))
	},
	
	#' @description 
	#' did execution of the function complete yet (or get cancelled). This can be used in a while loop.
	#' with an appropriate delay.
	isDone = function() {
		tmp = as.logical(rJava::.jcall(self$.jthread, returnSig='Z', method='isDone'))
		self$.api$printMessages()
		.jcheck()
		return(tmp)
	},
	
	#' @description 
	#' block execution until the function returns a value or throws an error. If the R session is 
	#' interrupted this will also interrupt the Java thread.
	#' @return the result of the function or an error.
	get = function() {
		complete = self$isDone()
		
		# On exit function here is to propagate R session interrupts into the Java
		# thread so it can shut down if this function is interrupted in R.
		on.exit(if (!complete) { self$cancel() })
		
		# Wait whilst polling for result. poll is false if the thread has not completed
		# if R is interrupted the function will exit and trigger java thread shutdown.
		# via the on.exit clause. The poll 20ms time delay will short circuit if the thread has finished.
		while(!as.logical(rJava::.jcall(self$.jthread, returnSig='Z', method='poll', .jlong(20)))) {
			# This is here to allow control to return to R briefly to allow for 
			# R session interruptions to be processed and for messages from java code to 
			# be relayed to the R terminal.
			self$.api$printMessages()
		}
		
		# If R was interrupted whilst java was still 
		# running this next part should not be executed and the function should
		# be running the on.exit hook to shut down the java thread.
		
		# isDone() should be true now. 
		complete = self$isDone()
		
		# thread is done but did it succeed?
		if (as.logical(rJava::.jcall(self$.jthread, returnSig='Z', method='succeeded'))) {
			# Yes, the thread completed normally, and the result should be available
			# It is a plain untyped java object when returned from the ThreadRunner.
			tmp_fut_out = .jcall(self$.jthread, returnSig='Ljava/lang/Object;', method='getSuccess')
			if (is.null(tmp_fut_out)) tmp_out = NULL
			else if (self$.returnSig == "V") tmp_out = NULL
			else tmp_out = .jcast(tmp_fut_out,self$.returnSig)
			# Deal with any outstanding messages or errors
			self$.api$printMessages()
			.jcheck()
			if (is.R6(self$.r6obj) && self$.r6obj$.jobj$equals(tmp_out)) {
				# The java result is the same object as the dispatching object 
				# return the original R6 object wrapper as a future fluent method
				# N.B. this is impossible if the method was called in a static context
				return(invisible(self$.r6obj))
			} else {
				# The return value is a primitive or other non object standard data type.
				# or a member fo the API. The converter will know to wrap it in an R6 class if needed.
				return(self$.converter(tmp_out))
			}
		} else {
			# No.
			# The thread completed but with errors. The result value in .jthread will
			# be an exception which we throw. No return value		
			rJava::.jcall(self$.jthread, returnSig='V', method='throwFailure', check=FALSE)
			self$.api$printMessages()
			.jcheck()
		}
	},
	
	print = function() {
		sprintf("Background call `%s(...)`: %s%s",
			self$.method,
			if (self$isDone()) "complete." else "executing.",
			if (self$isCancelled()) " (cancelled)" else ""
		)
	},
	
	finalize = function() {
		self$cancel()
	}
	
))
