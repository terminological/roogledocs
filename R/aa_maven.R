# Generated by r6-generator-maven-plugin: this file is embedded into the R directory in R6-generator projects
# This file is a core part of the `rmaven` library but is also designed to be
# embedded in other R packages using Java as a package private set of functions.
# If this second mode is used then the R package in which it is embedded will
# need to import `fs`, `rappsdir`, `rlang`, `stringr`, `rJava`, `utils`, `xml2`
# and `magrittr` packages.

## Java Virtal Machine functions ----

# find java home for JDK and sets system variable
.java_home = function(set = TRUE, quiet = getOption("rmaven.quiet",TRUE), require_jdk = FALSE) {
  jh = getOption("rmaven.java_home",NA)
  if (is.na(jh) || !fs::dir_exists(jh)) jh = Sys.getenv("JAVA_HOME", unset=NA)
  if (is.na(jh) || !fs::dir_exists(jh)) {
    if (!rJava::.jniInitialized) {
      warning(
      "Initialising rJava with default parameters to check for JAVA_HOME. ",
      "This probably should have been called after rJava::.jinit() or .start_jvm()")
      try({.start_jvm(quiet = TRUE)},silent=TRUE)
    }
    jh = tryCatch({rJava::.jcall( 'java/lang/System', 'S', 'getProperty', 'java.home' )},error = function(e) NA)
  }
  if(is.na(jh) || !fs::dir_exists(jh)) jh = utils::tail(unlist(stringr::str_split(Sys.getenv("LD_LIBRARY_PATH"),":")),1)
  if(is.na(jh) || !fs::dir_exists(jh)) stop("Could not determine JAVA_HOME from getOption('rmaven.java_home'), Sys.getenv('JAVA_HOME'), Sys.getenv('LD_LIBRARY_PATH'), or via 'rJava'")

  jh_orig = jh
  jh_parent = fs::path_dir(jh)
  while(!.is_jdk_home(jh) && jh_parent != jh) {
    # look for a jdk
    jh = jh_parent
    jh_parent = fs::path_dir(jh)
  }

  if (!.is_jdk_home(jh)) {

    if (require_jdk) stop("Couldn't find 'bin/javac(.exe)' in any parent directories starting at ",
                          jh_orig,", do you have a JDK installed?")
    # settle for a jre if we can find one
    jh = jh_orig
    jh_parent = fs::path_dir(jh)
    while(!.is_jre_home(jh) && jh_parent != jh) {
      # look for a jdk
      jh = jh_parent
      jh_parent = fs::path_dir(jh)
    }
    stop("Couldn't find 'bin/javac(.exe)' or 'bin/java(.exe)' in any parent directories starting at ",
         jh_orig,", please set options('rmaven.java_home'=...) to the root of a JDK (the directory containing 'bin/javac').")
  }
  if (set) Sys.setenv("JAVA_HOME"=jh)
  return(jh)
}

.is_jdk_home = function(path = .java_home(set=FALSE, quiet=TRUE)) {
  if(.Platform$OS.type == "windows") {
    return(
      fs::file_exists(fs::path(path,"bin/javac.exe"))
      # fs::file_exists(fs::path(path,"bin/javac.cmd")) ||
      # fs::file_exists(fs::path(path,"bin/javac.bin"))
    )
  } else {
    return(fs::file_exists(fs::path(path,"bin/javac")))
  }
}

.is_jre_home = function(path = .java_home(set=FALSE, quiet=TRUE)) {
  if(.Platform$OS.type == "windows") {
    return(fs::file_exists(fs::path(path,"bin/java.exe")))
  } else {
    return(fs::file_exists(fs::path(path,"bin/java")))
  }
}

# Start an `rJava` `JVM` with or without debugging options
#
# This does not do anything if the `JVM` has already been started. Otherwise
# starts the JVM via `rJava` with a set of options Additional JVM options
# (beyond debugging) can be set with thepackage
# `options("java.parameters"=c("-Xprof","-Xrunhprof"))`
#
# debug turn on debugging
# quiet don't report messages (defaults to `getOption("rmaven.quiet")` or TRUE)
# max_heap optional. if a string like `"2048m"` the `-Xmx` option value to start
# the `JVM` - if a string like `"75%"` the `-XX:MaxRAMPercentage`, if a numeric
# - number of megabytes. thread_stack optional. sensible values range from '1m'
# to '128m' (max is '1g'). Can be important with deeply nested structures. ...
# any other named parameters are passes as `-name` or `-name=value` if value is
# a character
.start_jvm = function(debug = FALSE, quiet = getOption("rmaven.quiet",TRUE),
                      max_heap = NULL, thread_stack = NULL, ...) {
  opts = getOption("java.parameters")
  if (!is.null(max_heap)) {
    # get rid of startup Xmx option
    opts = opts[substr(opts,1,4)!="-Xmx"]
    if ("%" == substr(max_heap,start = nchar(max_heap),nchar(max_heap))) {
      # ends with %
      max_heap = substr(max_heap,start = 1,nchar(max_heap)-1)
      opts = c(opts,sprintf("-XX:MaxRAMPercentage=%s.0",max_heap))
    } else if (is.numeric(max_heap)) {
      unit = "m" # if (max_heap > 32) "m" else "g"
      # assume number of megabytes
      opts = c(opts,sprintf("-Xmx%1.0f%s",max_heap,unit))
    } else {
      opts = c(opts,sprintf("-Xmx%s",max_heap))
    }
  }
  if (!is.null(thread_stack)) opts = c(opts,sprintf("-Xss%s",thread_stack))

  named = rlang::dots_list(..., .homonyms = "error")
  if (length(named) > 0) {
    named = named[!unlist(lapply(named, is.null))]
    named = named[names(named) != ""]
    opts2 = ifelse(
      unlist(named)=="",
      paste0("-",names(named)), # no option value needed
      paste0("-",names(named),"=",unlist(named))
    )
  } else {
    opts2 = NULL
  }

  opts = unname(c(opts, opts2))
  tryCatch({
    if (!rJava::.jniInitialized) {
      if (debug) {
      # pass in debug options
        rJava::.jinit(parameters=c(opts,"-Xdebug","-Xrunjdwp:transport=dt_socket,address=8998,server=y,suspend=n"), silent = TRUE, force.init = TRUE)
        if(!quiet) message("java debugging initialised on port 8998 with options: ",opts)
      } else {
        rJava::.jinit(parameters=opts,silent = TRUE, force.init = FALSE)
      }
    } else {
      if(!quiet) warning("The JVM was already initialised when .start_jvm(...) was called. ",
                         "The following parameters were not applied: ", opts)
    }
  }, error = function(e) {
    warning("")
    stop("Java cannot be initialised: ",e$message)
  })
}

## File functions ----

# Find location of all the jars in a particular package.
#
# package_name the R package name
# types the jar types to look for in the package: one of
#   `all`,`thin-jar`,`fat-jar`,`src`
#
# a vector of paths to jar files in the package
.package_jars = function(package_name, types = c("all","thin-jar","fat-jar","src")) {
  types = match.arg(types)
  pkgloc = system.file(package = package_name)
  if (pkgloc=="") stop("no package found for: ",package_name)
  files = fs::dir_ls(pkgloc,recurse = TRUE)
  if (types == "all") {
    return(files[fs::path_ext(files)=="jar"])
  } else if (types == "thin-jar") {
    return(.unclassified_jars_only(files))
  } else if (types == "fat-jar") {
    return(.classified_jars_only(files,"jar-with-dependencies"))
  } else if (types == "src") {
    return(.classified_jars_only(files,"src"))
  }
  stop("package jars, unknown type: ",types)
}

# internal function
.unclassified_jars_only = function(files) {
  files = files[fs::path_ext(files)=="jar"]
  matched = apply(
    matrix(
      sapply(.classifier_opts, function(c) (stringr::str_ends(fs::path_ext_remove(files), c))),
      ncol = length(.classifier_opts)),
    1, any) # collapse rowwise using any()
  files = files[!matched]
  return(files)
}

# internal function
# e.g. classifier = "jar-with-dependencies"
.classified_jars_only = function(files, classifier) {
  files = files[fs::path_ext(files)=="jar"]
  files = files[stringr::str_ends(fs::path_ext_remove(files), classifier)]
  return(files)
}

# internal function
# all caches are in a sub-directory of the rmaven
.working_dir = function(artifact = "", subpath="") {
  artifact = stringr::str_replace_all(artifact,stringr::fixed(":"),"_")
  tmp = fs::path_expand(fs::path(rappdirs::user_cache_dir("rmaven"),artifact, subpath))
  fs::dir_create(tmp)
  return(tmp)
}

# internal function
.working_file = function(path, artifact="", subpath = "") {
  return(fs::path(.working_dir(artifact, subpath=subpath), path))
}

# internal function
# detect if `test` file exists and is newer that `original`
# if original file does not exist then test is always newer.
.is_newer_than = function(test, original) {
  if (!file.exists(original)) return(TRUE)
  if (!file.exists(test)) stop("test file doesn't exist: ",test)
  as.POSIXct(file.info(original)$mtime) < as.POSIXct(file.info(test)$mtime)
}

.copy_jf_newer_than = function(source, destination) {
  if (source %>% .is_newer_than(destination))
    fs::file_copy(source,destination)
}

## Maven coordinates functions ----

.classifier_opts = c("tests", "client", "sources", "javadoc", "jar-with-dependencies", "src")
.packaging_opts = c("jar","ejb","pom","war")


# Prints a coordinates object
#
# @param x a maven coordinates object
# @param ... ignored
.print.coordinates = function(x,...) {
  print(.artifact(x))
}

# Maven coordinates
#
# @param groupId the maven `groupId`
# @param artifactId the maven `artifactId`
# @param version the maven version
# @param ... other parameters ignored apart from `packaging` (one of
#   `jar`,`war`,`pom` or `ejb`) and `classifier` (one of `tests`, `client`,
#   `sources`, `javadoc`, `jar-with-dependencies`, `src`)
.as.coordinates = function(groupId, artifactId, version, ...) {
  out = list(
    groupId = groupId,
    artifactId = artifactId,
    version = version,
    packaging = NULL,
    classifier = NULL
  )
  class(out) = c("coordinates",class(out))
  coordinates = rlang::list2(...)
  if (is.null(coordinates$packaging)) coordinates$packaging = "jar"
  if (!coordinates$packaging %in% .packaging_opts)
    stop('if packaging given it must be one of ',paste0(.packaging_opts, collapse=", "))
  out$packaging = coordinates$packaging
  if (!is.null(coordinates$classifier)) {
    if (!coordinates$classifier %in% .classifier_opts)
      stop('if classifier option is given it must be one of',paste0(.classifier_opts, collapse=", "))
    out$classifier = coordinates$classifier
  }
  return(out)
}

# internal function
# get maven artifact coordinates from groupId, artifactId, etc.
.artifact = function(coordinates) {
  out = sprintf("%s:%s:%s", coordinates$groupId, coordinates$artifactId,
                coordinates$version)
  if (
    # packaging is present
    !is.null(coordinates$packaging) &&
    # unless packaging is "jar" and no classifier.
    !(coordinates$packaging == "jar" && is.null(coordinates$classifier))) {
    out = sprintf("%s:%s", out, coordinates$packaging)
    if (!is.null(coordinates$classifier)) {
      out = sprintf("%s:%s", out, coordinates$classifier)
    }
  }
  return(out)
}

# internal function
# coordinates = .coordinates(artifact="io.github.terminological:r6-generator:main-SNAPSHOT:pom")
.coordinates = function(artifact) {
  pieces = stringr::str_split_fixed(artifact,":",n=Inf)[1,]
  return(.as.coordinates(
    groupId = pieces[1],
    artifactId = pieces[2],
    version = if(length(pieces) > 2) pieces[3] else "LATEST",
    packaging = if(length(pieces) > 3) pieces[4] else NULL,
    classifier = if(length(pieces) > 4) pieces[5] else NULL
  ))
}

# internal function
# jar_path = .m2_path(.coordinates(artifact="io.github.terminological:r6-generator-docs:main-SNAPSHOT"))
# coordinates = .coordinates_from_jar(jar_path)
# .m2_path(coordinates) == jar_path
.coordinates_from_jar = function(jar_path) {
  paths = utils::unzip(jar_path, list = TRUE)
  pom_paths = paths$Name[fs::path_file(paths$Name) == "pom.xml"]
  for (pom_path in pom_paths) {
    # pom_path = pom_paths[1]
    utils::unzip(jar_path,junkpaths = TRUE,files = pom_path,exdir = tempdir(),overwrite = TRUE)
    coords = .coordinates_from_pom(fs::path(tempdir(),"pom.xml"))

    # If there is only one pom.xml return that, or if there are multiple, return first that matches the artifactId
    # NB this might under match a bit e.g. r6-generator, could match r6-generator, r6-generator-docs, r6-generator-runtime
    if (
      length(pom_paths) == 1 |
      stringr::str_starts(fs::path_file(jar_path), unlist(coords$artifactId))
    ) {

      if (stringr::str_starts(pom_path,"META-INF/maven")) {
        if (stringr::str_ends(jar_path,"jar-with-dependencies.jar")) coords$classifier = "jar-with-dependencies"
      } else if (stringr::str_ends(jar_path,"src.jar")) {
        coords$classifier = "src"
      }

      return(coords)
    }
  }
  stop("multiple poms found and none have artifactId matching jar name.")
}

# internal function
.coordinates_from_pom = function(pom_path) {
  pomxml = xml2::read_xml(pom_path) %>% xml2::as_list()
  coords = .as.coordinates(
    groupId = unlist(pomxml$project$groupId),
    artifactId = unlist(pomxml$project$artifactId),
    version = unlist(pomxml$project$version),
    packaging = unlist(pomxml$project$packaging),
    classifier = NULL
  )
  return(coords)
}

# internal function
# this is the filename part of a path from maven coordinates
.filename = function(coordinates) {
  if(is.null(coordinates$classifier)) {
    return(sprintf("%s-%s.%s", coordinates$artifactId, coordinates$version,
                   coordinates$packaging))
  } else {
    return(sprintf("%s-%s-%s.%s", coordinates$artifactId, coordinates$version,
                   coordinates$classifier, coordinates$packaging))
  }
}

# internal function
.pom_archive_path = function(coordinates) {
  if (
    is.null(coordinates$classifier) # a normal jar file
    || coordinates$classifier == "jar-with-dependencies" # a fat jar file
  ) {
    return(sprintf("META-INF/maven/%s/%s/pom.xml", coordinates$groupId,
                   coordinates$artifactId))
  } else if (
    coordinates$classifier == "src" # a maven assembly source archive file
  ) {
    return(sprintf("%s-%s/pom.xml", coordinates$artifactId, coordinates$version))
  } else {
    stop("there is no pom.xml stored in ",
         sprintf("-%s-%s-%s.%s", coordinates$artifactId, coordinates$version,
                 coordinates$classifier, coordinates$packaging))
  }
}

# internal function
.m2_path = function(coordinates) {
  groupPath = stringr::str_replace_all(coordinates$groupId, stringr::fixed("."), "/")
  repoPath = sprintf("%s/%s/%s/%s",groupPath,coordinates$artifactId,coordinates$version,.filename(coordinates))
  return(fs::path(.get_repository_location(), repoPath))
}

## Settings.xml ----

.settings_path = function() {
  out = fs::path(tempdir(),"rmaven/settings.xml")
  fs::dir_create(fs::path_dir(out))
  return(out)
}



# Sets the local maven repository location
#
# This writes a maven repository location to a temporary `settings.xml` file
# which persists only for the R session. The location of the maven repository is
# either specified here, or can be defined by the
# `options("rmaven.m2.repository"=...)` option. If neither of these is provided,
# the location will revert to a default location within the `rmaven` cache.
# (Approved by CRAN for a local cache location) e.g. on 'Linux' this will
# default to `~/.cache/rmaven/.m2/repository/`
#
# @param repository_location a file path (which will be expanded to a full path)
#   where the repository should be based, e.g. `~/.m2/repository/`. Defaults to
#   a sub-directory of the `rmaven` cache.
# @param settings_path the file path of the settings.xml to update (generally
#   the supplied default is what you want to use)
.set_repository_location = function(
    repository_location = getOption("rmaven.m2.repository",default = .working_dir(subpath=".m2/repository/")),
    settings_path = .settings_path()
  ) {
  repository_location = fs::path_expand(repository_location)
  if (fs::file_exists(settings_path)) {
    settings_list = xml2::read_xml(settings_path) %>% xml2::as_list()
    # If no change to setting then short circuit this
    if (settings_list$settings$localRepository[[1]] == repository_location) return(repository_location)
    settings_list$settings$localRepository[[1]] = fs::path_expand(repository_location)
  } else {
    # default settings
    settings_list = list(settings=structure(
      list(localRepository=list(repository_location)),
      xmlns="http://maven.apache.org/SETTINGS/1.0.0",
      "xmlns:xsi"="http://www.w3.org/2001/XMLSchema-instance" #,
      # Not sure why but this is throwing a warning in maven:
      # "xsi:schemaLocation"="http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd"
    ))
  }
  settings_xml = xml2::as_xml_document(settings_list)
  xml2::write_xml(settings_xml, settings_path, options=c("format"))
  return(repository_location)
}

# Get the location of the Maven repository
#
# In general this function is mainly for internal use but maybe handy for
# debugging. The maven repository location can be defined by
# `.set_repository_location(...)` or through the option
# `options("rmaven.m2.repository"=...)` option but defaults to a
# `.m2/repository` directory in the `rmaven` cache directory. This is not the
# default location for Maven when used from Java writing to the default Maven
# directory in user space is forbidden by CRAN policies. The result of this is
# that `rmaven` will have to unnecessarily download additional copies of java
# libraries, onto the users computer and cannot re-use already cached copies.
# This is more of an issue for developers rather than users.
.get_repository_location = function(settings_path = .settings_path()) {
  if (fs::file_exists(settings_path)) {
    settings_list = xml2::read_xml(settings_path) %>% xml2::as_list()
    return(fs::path(settings_list$settings$localRepository[[1]]))
  } else {
    # make sure a settings.xml exists
    # and return the default
    return(.set_repository_location())
  }
}


# Clear out the `rmaven` cache
#
# Deletes all content in the `rmaven` cache. This should not be necessary, but
# never say never, and if there is really a problem with the cache, then
# deleting it may be the best thing. This will wait for confirmation from the
# user. If running unattended the `options("rmaven.allow.cache.delete"=TRUE)`
# must be set for the action to occur, otherwise it will generate a warning and
# do nothing.
#
.clear_rmaven_cache = function() {
  dir = .working_dir()
  if (!interactive()) {
    if (getOption("rmaven.allow.cache.delete",FALSE)) {
      fs::dir_delete(dir)
    } else {
      warning("the option rmaven.allow.cache.delete was not TRUE (or not set)")
      message("so we can't delete the rmaven cache in an unattended script")
    }
  } else {

    cat("
You are about to delete all cached rmaven content including compiled and
downloaded jar files. In theory this can all be rebuilt but it may take some
time and bandwidth. If you want you can do this in a more targetted way
manually by looking at: ",dir,"\n",sep="")
    sure = utils::menu(c("Yes","No"), title="Are you sure?")
    if (sure == 1) {
      message("deleting cached content in: ", dir)
      fs::dir_delete(dir)
    }

  }
}

## Maven command functions ----

# internal function
# loads a maven wrapper distribution from the internet and unzips it into the rmaven working directory
.load_maven_wrapper = function(quiet = getOption("rmaven.quiet",TRUE)) {
  dir = .working_dir()
  if (!file.exists(.working_file("mvnw"))) {

    destfile = .working_file("wrapper.zip")
    if(!quiet) message("Bootstrapping maven wrapper.")
    utils::download.file(
      "https://repo1.maven.org/maven2/org/apache/maven/wrapper/maven-wrapper-distribution/3.1.1/maven-wrapper-distribution-3.1.1-bin.zip",
      destfile = destfile,
      quiet = TRUE
    )
    utils::unzip(destfile,exdir=dir)
    unlink(destfile)
    if(!file.exists(.working_file("mvnw"))) stop("downloading maven wrapper has not been successful")

    write(c(
      "distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.3.9/apache-maven-3.3.9-bin.zip",
      "wrapperUrl=https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.1.1/maven-wrapper-3.1.1.jar"
    ), .working_file(".mvn/wrapper/maven-wrapper.properties"))

  }
  if(.Platform$OS.type == "windows") {
    mvnPath = .working_file("mvnw.cmd")
  } else {
    mvnPath = .working_file("mvnw")
  }

  Sys.chmod(mvnPath)
  return(mvnPath)
}

# verbosity settings
# defaults to quiet
.quietly = function(verbose = "normal") {
  if (verbose == "quiet") return(TRUE)
  if (verbose == "debug") return(FALSE)
  return(getOption("rmaven.quiet",FALSE))
}

# debug settings
# defaults to
.debug = function(verbose = "normal") {
  if (verbose == "debug") return(TRUE)
  if (verbose == "quiet") return(FALSE)
  return(getOption("rmaven.debug",FALSE))
}

# Executes a maven goal
#
# Maven goals are defined either as life-cycle goals (e.g. "clean", "compile")
# or as plugin goals (e.g. "help:system"). Some Maven goals may be executed
# without a `pom.xml` file, others require one. Some maven goals (e.g.
# compilation) require the use of a `JDK`.
#
# @param goal the goal of the `mvn` command ( can be multiple ) e.g.
#   `c("clean","compile")`
# @param opts provided options in the form
#   `c("-Doption1=value2","-Doption2=value2")`
# @param pom_path optional. the path to a `pom.xml` file for goals that need
#   one.
# @param quiet should output from maven be suppressed? (`-q` flag)
# @param debug should output from maven be verbose? (`-X` flag)
# @param verbose how much output from maven, one of "normal", "quiet", "debug"
# @param require_jdk does the goal you are executing require a `JDK` (e.g.
#   compilation does, fetching artifacts and calculating class path does not)
# @param settings the path to a `settings.xml` file controlling Maven. The
#   default is a configuration with a local repository in the `rmaven` cache
#   directory (and not the Java maven repository).
# @param ... non-empty named parameters are passed to maven as options in the
#   form `-Dname=value`
.execute_maven = function(
  goal, opts = c(),
  pom_path=NULL,
  quiet=.quietly(verbose),
  debug=.debug(verbose),
  verbose = c("normal","debug","quiet"),
  require_jdk=FALSE,
  settings = .settings_path(),
  ...
) {
  verbose = match.arg(verbose)
  mvn_path = .load_maven_wrapper()
  named = rlang::dots_list(..., .homonyms = "error")
  # the following is not used but calling it forces checking and creation of
  # the file if missing.
  repo_loc = .get_repository_location(settings_path = settings)
  # filter out unnamed
  # named = list(1,x=2,y="",z=NULL)
  if (length(named) > 0) {
    named = named[!unlist(lapply(named, is.null))]
    named = named[unlist(named) != ""]
    named = named[names(named) != ""]
    opts2 = paste0("-D",names(named),"=",unlist(named))
  } else {
    opts2 = NULL
  }

  args = c(goal, opts, opts2,
    "-B", # batch mode
    paste0("-s \"",settings,"\"") # user setting file location
  )
  # This is not needed as we set WD to the pom path or maven path below
  # due to some windows Mvnw.cmd issue.
  # if (!is.null(pom_path)) args = c(args, paste0("-f \"",pom_path,"\""))
  if (quiet) args = c(args, "-q")
  else if (debug) args = c(args, "-X")
  else {
    # not quiet or debug.
    # we will go for the option which displays maven output but removes the
    # download indicators and details.
    # https://stackoverflow.com/questions/21638697/disable-maven-download-progress-indication
    args = c(args,"-Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn")
  }
  # make sure JAVA_HOME is set
  .java_home(quiet=TRUE)

  # changing the wd is required due to an issue in Mvnw.cmd on windows.
  wd = getwd()
  # change the working directory
  if(!is.null(pom_path)) {
    setwd(fs::path_dir(pom_path))
  } else {
    setwd(fs::path_dir(mvn_path))
  }

  args = unique(args)
  if (debug) message("executing: ",mvn_path," ",paste0(args,collapse=" "))
  out = system2(mvn_path, args, stdout = TRUE)
  if (!quiet) cat(paste0(c(out,""),collapse="\n"))
  setwd(wd)
  invisible(NULL)
}

# Fetch an artifact from a remote repository into the local .m2 cache
#
# @param groupId optional, the maven `groupId`,
# @param artifactId optional, the maven `artifactId`,
# @param version optional, the maven version,
# @param ... other maven coordinates such as classifier or packaging
# @param coordinates optional, coordinates as a coordinates object,
# @param artifact optional, coordinates as an artifact string
#   `groupId:artifactId:version[:packaging[:classifier]]` string
# @param repoUrl the URLs of the repositories to check (defaults to Maven
#   central, 'Sonatype' snapshots and 'jitpack', defined in
#   `options("rmaven.default_repos"))`
# @param coordinates optional, but if not supplied `groupId` and `artifactId`
#   must be, coordinates as a coordinates object (see `.as.coordinates()`)
# @param artifact optional, coordinates as an artifact string
#   `groupId:artifactId:version[:packaging[:classifier]]` string
# @param nocache normally artifacts are only fetched if required, `nocache`
#   forces fetching
# @param verbose how much output from maven, one of "normal", "quiet", "debug"
.fetch_artifact = function(
    groupId = NULL,
    artifactId = NULL,
    version = NULL,
    ...,
    coordinates = NULL,
    artifact = NULL,
    repoUrl = .default_repos(),
    nocache = FALSE,
    verbose = c("normal","quiet","debug")
) {
  if ((is.null(groupId) || is.null(artifactId) || is.null(version)) && is.null(coordinates) && is.null(artifact)) {
    stop("one of groupId,artifactId + version or coordinates or artifact must be given")
  }

  if (!is.null(coordinates)) {
    artifact = .artifact(coordinates)
  } else if (!is.null(artifact)) {
    coordinates = .coordinates(artifact)
  } else {
    coordinates = .as.coordinates(groupId, artifactId, version, ...)
    artifact = .artifact(coordinates)
  }

  verbose = match.arg(verbose)
  if(is.null(coordinates)) coordinates = .coordinates(artifact)
  target = .m2_path(coordinates)
  if (nocache) unlink(target)
  if (!fs::file_exists(target)) {
    .execute_maven(
      goal = "org.apache.maven.plugins:maven-dependency-plugin:3.3.0:get",
      remoteRepositories = paste0(repoUrl,collapse = ","),
      artifact = artifact,
      verbose = verbose,
      require_jdk = FALSE
    )
  }
  if (!fs::file_exists(target)) stop("did not sucessfully fetch artifact: ",target)
  return(target)
}



# Copy an artifact from a repository to a local directory
#
# This essentially runs a `maven-dependency-plugin:copy` goal to copy a JAR file
# from a remote repository to a local directory.
#
# @param groupId optional, the maven `groupId`,
# @param artifactId optional, the maven `artifactId`,
# @param version optional, the maven version,
# @param ... other maven coordinates such as classifier or packaging
# @param coordinates optional, coordinates as a coordinates object,
# @param artifact optional, coordinates as an artifact string
#   `groupId:artifactId:version[:packaging[:classifier]]` string
# @param repoUrl the URLs of the repositories to check (defaults to maven
#   central, `Sonatype snaphots` and `jitpack`)
# @param outputDirectory optional path, defaults to the `rmaven` cache directory
# @param nocache normally artifacts are only fetched if required, `nocache`
#   forces fetching
# @param verbose how much output from maven, one of "normal", "quiet", "debug"
.copy_artifact = function(
    groupId = NULL,
    artifactId = NULL,
    version = NULL,
    ...,
    coordinates = NULL,
    artifact = NULL,
    outputDirectory = .working_dir(artifact),
    repoUrl = .default_repos(),
    nocache = FALSE,
    verbose = c("normal","quiet","debug")
) {
  verbose = match.arg(verbose)

  if ((is.null(groupId) || is.null(artifactId) || is.null(version)) && is.null(coordinates) && is.null(artifact)) {
    stop("one of groupId,artifactId + version or coordinates or artifact must be given")
  }

  if (!is.null(coordinates)) {
    artifact = .artifact(coordinates)
  } else if (!is.null(artifact)) {
    coordinates = .coordinates(artifact)
  } else {
    coordinates = .as.coordinates(groupId, artifactId, version, ...)
    artifact = .artifact(coordinates)
  }

  target = fs::path(outputDirectory,.filename(coordinates))
  if (nocache) unlink(target)
  if (!fs::file_exists(.m2_path(coordinates))) {
    .fetch_artifact(artifact=artifact, verbose = verbose)
  }
  if (!fs::file_exists(.m2_path(coordinates))) {
    .execute_maven(
      goal = "org.apache.maven.plugins:maven-dependency-plugin:3.3.0:copy",
      artifact = artifact,
      outputDirectory = outputDirectory,
      require_jdk = FALSE,
      verbose = verbose
    )
    if (!fs::file_exists(target)) stop("Couldn't copy artifact from local .m2 repo or from repositories")
  } else {
    fs::file_copy(
      .m2_path(coordinates),
      target,
      overwrite = TRUE
    )
  }
  return(target)
}

# # gets the pom.xml file for ${model.getMavenCoordinates()} from a thin jar
.extract_pom = function(
    coordinates,
    path = .m2_path(coordinates),
    artifact = .artifact(coordinates),
    nocache=FALSE,
    verbose = c("normal","quiet","debug")
) {
  verbose = match.arg(verbose)
  dir = .working_dir(artifact)
  target = .working_file("pom.xml", artifact)
  if (nocache) unlink(target)

  if (fs::is_dir(path)) {
    pom_path = fs::path(path,"pom.xml")
    if(!fs::file_exists(pom_path)) stop("no pom found at: ",pom_path)
    # we assume in this case that the path is to a source directory
    pom_path %>% .copy_jf_newer_than(target)
    return(target)
  }

  if (coordinates$packaging == "pom") {
    # this is a direct link to a pom file
    if(!fs::file_exists(path)) stop("no pom found at: ",path)
    fs::path(path) %>% .copy_jf_newer_than(target)
    return(target)
  }

  # does this refer to something that has not yet been downloaded
  if (path == .m2_path(coordinates) && !fs::file_exists(path)) {
    .fetch_artifact(coordinates=coordinates, verbose = verbose)
  }

  # this is a jar file (or war, or ejb)
  if (path %>% .is_newer_than(target)) {
    # .pom_archive_path will detect the different types of jar files
    suppressWarnings(try({utils::unzip(path, files = .pom_archive_path(coordinates), junkpaths = TRUE, exdir = dir)},silent = TRUE))
    unzipped_pom = fs::path(dir,fs::path_file(.pom_archive_path(coordinates)))
    if (!fs::file_exists(unzipped_pom)) {
      # stop("couldn't extract pom from presumed jar file: ",path)
      coordinates$packaging = "pom"
      return(.extract_pom(coordinates,artifact = artifact))
      # this is a good idea bu the pom here is only a stub.
    }
    if (unzipped_pom != target) { fs::file_move(unzipped_pom,target) } # I don't see why this should even happen. Only if the pom is not called pom.xml
  }
  return(target)
}

.classpath_file_to_string = function(path) {
  if(.Platform$OS.type == "windows") {
    classpath_string = unique(scan(path, what = "character", sep=";", quiet=TRUE))
  } else {
    classpath_string = unique(scan(path, what = "character", sep=":", quiet=TRUE))
  }
  return(classpath_string)
}

# Resolve the `classpath` for an artifact
#
# This calculates the dependencies for an artifact which may be specified either
# as a set of maven coordinates (in which case the artifact is downloaded, and
# included in the `classpath`) or as a path to a jar file containing a pom.xml
# (e.g. a compiled jar file, a compiled jar-with-dependencies, or a assembled
# `...-src.jar`) The resulting file paths which will be in the maven local cache
# are checked on the file system.
#
# @param groupId the maven `groupId`, optional
# @param artifactId the maven `artifactId`, optional
# @param version the maven version, optional
# @param ... passed on to .as.coordinates()
# @param coordinates the maven coordinates, optional (either
#   `groupId`,`artifactId` and 'version' must be specified, or 'coordinates', or
#   'artifact')
# @param artifact optional, coordinates as an artifact string
#   `groupId:artifactId:version[:packaging[:classifier]]` string
# @param path the path to the source directory, pom file or jar file. if not
#   given `rmaven` will get the artifact from the maven central repositories
# @param include_self do you want include this path in the `classpath`.
#   optional, if missing the path will be included if it is a regular jar, or a
#   fat jar, otherwise not.
# @param nocache do not used cached version, by default we use a cached version
#   of the `classpath` unless the `pom.xml` is newer that the cached
#   `classpath`.
# @param verbose how much output from maven, one of "normal", "quiet", "debug"
#
# @return a character vector of the `classpath` jar files (including the current
#   one if appropriate)
.resolve_dependencies = function(
    groupId = NULL,
    artifactId = NULL,
    version = NULL,
    ...,
    coordinates = NULL,
    artifact = NULL,
    path = NULL,
    include_self = NULL,
    nocache = FALSE,
    verbose = c("normal","quiet","debug")
) {
  verbose = match.arg(verbose)

  if ((is.null(groupId) || is.null(artifactId) || is.null(version)) && is.null(coordinates) && is.null(artifact)) {
    if (is.null(path) || fs::path_ext(path) != "jar") stop("if neither of groupId + artifactId + version or coordinates or artifact is given, path must point to a jar file containing a pom.xml")
    coordinates = .coordinates_from_jar(path)
  }

  if (!is.null(coordinates)) {
    artifact = .artifact(coordinates)
  } else if (!is.null(artifact)) {
    coordinates = .coordinates(artifact)
  } else {
    coordinates = .as.coordinates(groupId, artifactId, version, ...)
    artifact = .artifact(coordinates)
  }

  if (is.null(path)) {
    path = .m2_path(coordinates)
    if (!file.exists(path) || nocache) {
      .fetch_artifact(coordinates = coordinates, nocache = nocache, verbose = verbose)
    }
  }

  include_self = (coordinates$packaging == "jar" && (is.null(coordinates$classifier) || coordinates$classifier == "jar-with-dependencies"))

  dir = .working_dir(artifact = .artifact(coordinates))
  classpath_path = .working_file("classpath.txt",artifact = .artifact(coordinates))
  pom_path = .extract_pom(coordinates, path, nocache = nocache, verbose = verbose)

  if (nocache) unlink(classpath_path)

  # If the classpath file is already there we need to check that the entries on the class path are indeed available on this machine
  # as they may have been moved or deleted
  if(file.exists(classpath_path)) {
    classpath_string = .classpath_file_to_string(classpath_path)
    if (!all(file.exists(classpath_string))) {
      # we need to rebuild the classpath file anyway as some dependencies are not available
      unlink(classpath_path)
    }
  }

  if(pom_path %>% .is_newer_than(classpath_path)) {
    if (.quietly(verbose)) message("Calculating classpath and updating dependencies, please be patient.")
    .execute_maven(
      pom_path = pom_path,
      goal = "dependency:build-classpath",
      mdep.outputFile="classpath.txt",
      includeScope="runtime",
      verbose = verbose,
      require_jdk = FALSE
    )
  }

  if (!fs::file_exists(classpath_path)) stop("classpath not created")
  classpath_string = .classpath_file_to_string(classpath_path)
  if (include_self) classpath_string = c(path,classpath_string)

  if (!all(file.exists(classpath_string)))
    stop("some classpath dependencies are not resolveable:\n",paste0(classpath_string[!file.exists(classpath_string)],collapse = "\n"))
  return(unique(classpath_string))
}

# Compilation ----

# path is a directory or a `...-src.jar` file
# here::i_am("R/maven.R")
# path = here::here("java/test-project-0.0.1-SNAPSHOT-src.jar")
# path = here::here("java/test-project")
# .extract_source_code
.extract_source_code = function(path) {

  if (fs::is_dir(path)) {
    # an un jarred source directory
    pom_path = fs::path(path,"pom.xml")
    if (!fs::file_exists(pom_path)) stop("we didn't find a pom.xml file at ",pom_path)
    coordinates = .coordinates_from_pom(pom_path)
    versioned = sprintf("%s-%s", coordinates$artifactId, coordinates$version)
    copy_dir = .working_dir(.artifact(coordinates), subpath = versioned)
    # overwrite = TRUE means the directory contents pf 'path' are directly written into 'copy_dir' rather than as a subdirectory
    fs::dir_copy(path, copy_dir,overwrite = TRUE)
  } else {
    if (!fs::file_exists(path) || fs::path_ext(path) != "jar") stop("we didn't find a jar file at ",path)
    coordinates = .coordinates_from_jar(path)
    if (coordinates$classifier != "src") stop("this routine only works for '...-src.jar' files of the type created by mvn assembly plugin")
    unzip_dir = .working_dir(.artifact(coordinates))
    utils::unzip(path, exdir = unzip_dir,overwrite = TRUE)
    versioned = sprintf("%s-%s", coordinates$artifactId, coordinates$version)
  }

  new_pom_path = .working_file("pom.xml", .artifact(coordinates), subpath = versioned)
  if (!fs::file_exists(new_pom_path)) stop("cannot find pom.xml from extracted source code")
  return(new_pom_path)

}

.do_compile = function(
  goal, opts, path, classifier = NULL, nocache = FALSE,
  verbose = c("normal", "quiet", "debug"), ...
) {

  verbose = match.arg(verbose)

  if (!fs::file_exists(path)) stop("The was nothing to compile at: ",path)

  if (fs::path_ext(path) == "xml") {
    pom_path = path
  } else {
    pom_path = .extract_source_code(path)
  }

  coordinates = .coordinates_from_pom(pom_path)
  project_dir = fs::path_dir(pom_path)

  if (is.null(classifier)) {
    target_jar = fs::path(project_dir,"target",sprintf("%s-%s.jar", coordinates$artifactId, coordinates$version))
  } else {
    target_jar = fs::path(project_dir,"target",sprintf("%s-%s-%s.jar", coordinates$artifactId, coordinates$version, classifier))
  }

  if (nocache) unlink( fs::path(project_dir,"target"), recursive = TRUE)

  if (path %>% .is_newer_than(target_jar)) {
    if (.quietly(verbose)) message("Compiling Java library, please be patient.")
    .execute_maven(
      pom_path,
      goal = goal,
      opts = opts,
      verbose = verbose,
      require_jdk = TRUE,
      ...
    )
  } else {
    if (!.quietly(verbose)) message("Compilation aready performed")
  }

  if(!file.exists(target_jar)) stop("could not compile java and assemble file: ",fs::path_file(target_jar))

  return(target_jar)
}


# Compile and package Java code
#
# Compilation will package the Java source code in to a Jar file for further
# use. It will resolve dependencies and optionally package them into a single
# `uber jar` (using maven assembly).
#
# @param path the path to - either a java source code directory containing a
#   `pom.xml` file, the `pom.xml` file itself, or a `...-src.jar` assembled by
#   the maven assembly plugin,
# @param nocache normally compilation is only performed if the input has
#   changed. `nocache` forces recompilation
# @param verbose how much output from maven, one of "normal", "quiet", "debug"
# @param with_dependencies compile the Java code to a
#   '...-jar-with-dependencies.jar' including transitive dependencies which may
#   be easier to embed into R code as does not need a class path (however may be
#   large if there are a lot of dependencies)
# @param ... passed to `.execute_maven(...)`, e.g. could include `settings`
#   parameter
.compile_jar = function(
  path,
  nocache = FALSE,
  verbose = c("normal", "quiet", "debug"),
  with_dependencies = FALSE,
  ...
) {

  verbose = match.arg(verbose)

  if (with_dependencies) {
    target_jar = .do_compile(
      goal = c("compile","assembly:single","package"),
      opts = c(
        "-DdescriptorId=jar-with-dependencies",
        "-Dmaven.test.skip=true"
      ),
      path = path,
      classifier = "jar-with-dependencies",
      nocache = nocache,
      verbose = verbose,
      ...
    )
  } else {
    target_jar = .do_compile(
      goal = c("compile","package"),
      opts = c(),
      path = path,
      nocache = nocache,
      verbose = verbose,
      ...
    )
  }

  return(target_jar)
}

# TODO: put this into the settings.xml
.default_repos = function() {
  getOption("rmaven.default_repos", default = c(
    "https://repo1.maven.org/maven2/",
    "https://s01.oss.sonatype.org/content/repositories/snapshots/",
    "https://jitpack.io"
  ))
}
